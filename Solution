#Eben Udeh 11/4/22
#Newton Raphson Iterative algorithm for 4 bus network
#Portland State University
#Electrical and Computer Engineering
#written for python 3.7+

import numpy as np
import math
import cmath
import torch
from torch.autograd.functional import jacobian

# ------------------------------------------
# System data: 4-bus Y-bus (balanced, single-phase equivalent)
# ------------------------------------------
Y_bus_np = np.array([
    [ 3.0 - 9.0j,   -2.0 + 6.0j,   -1.0 + 3.0j,   0.0 + 0.0j ],
    [-2.0 + 6.0j,   3.666 - 11.0j, -0.666 + 2.0j, -1.0 + 3.0j],
    [-1.0 + 3.0j,  -0.666 + 2.0j,  3.666 - 11.0j, -2.0 + 6.0j],
    [ 0.0 + 0.0j,   -1.0 + 3.0j,   -2.0 + 6.0j,   3.0 - 9.0j ]
])

# Convert to torch tensors (magnitudes and angles) for autograd use
Y_mag = torch.tensor(np.abs(Y_bus_np), dtype=torch.float64)
Y_theta = torch.tensor(np.angle(Y_bus_np), dtype=torch.float64)  # radians

# Slack bus is bus 1 (index 0): |V1| = 1.0 pu, δ1 = 0 rad
V1_mag = 1.0
V1_ang = 0.0

# ------------------------------------------
# Specified net power injections at buses 2–4 (P and Q)
# Convention: positive = net generation, negative = net load
# S_spec = [P2, P3, P4, Q2, Q3, Q4]
# ------------------------------------------
S_spec_np = np.array([
    [ 0.5],   # P2
    [-1.0],   # P3
    [ 0.3],   # P4
    [-0.2],   # Q2
    [ 0.5],   # Q3
    [-0.1]    # Q4
], dtype=float)

S_spec = torch.tensor(S_spec_np.flatten(), dtype=torch.float64)  # shape (6,)

# ------------------------------------------
# Power injection calculation using polar voltages
# Input:
#   x[0:3] = angles at buses 2–4 (radians)
#   x[3:6] = magnitudes at buses 2–4
# Output:
#   torch.tensor([P2,P3,P4,Q2,Q3,Q4])
# ------------------------------------------
def power_injections(x: torch.Tensor) -> torch.Tensor:
    """
    Compute real and reactive power injections at buses 2–4
    given state vector x = [δ2, δ3, δ4, |V2|, |V3|, |V4|].
    """
    # Full system angles and magnitudes (4 buses)
    ang = torch.zeros(4, dtype=torch.float64)
    vmag = torch.zeros(4, dtype=torch.float64)

    # Slack bus (bus 1)
    ang[0] = V1_ang
    vmag[0] = V1_mag

    # PQ buses: buses 2–4 (global indices 1,2,3)
    ang[1:4] = x[0:3]      # δ2, δ3, δ4 in radians
    vmag[1:4] = x[3:6]     # |V2|, |V3|, |V4|

    P = torch.zeros(4, dtype=torch.float64)
    Q = torch.zeros(4, dtype=torch.float64)

    # Standard polar-form power equations
    for i in range(4):
        for j in range(4):
            P[i] += vmag[i] * vmag[j] * Y_mag[i, j] * torch.cos(ang[i] - ang[j] - Y_theta[i, j])
            Q[i] += vmag[i] * vmag[j] * Y_mag[i, j] * torch.sin(ang[i] - ang[j] - Y_theta[i, j])

    # Return injections at buses 2–4 only (indices 1,2,3)
    return torch.stack([P[1], P[2], P[3], Q[1], Q[2], Q[3]])  # shape (6,)


# ------------------------------------------
# Newton–Raphson solver
# ------------------------------------------
def newton_raphson_power_flow(
    max_iter: int = 50,
    tol: float = 1e-10
):
    # Initial voltage guess in rectangular form (you can tweak this)
    v_init = np.array([
        1.03 + 0.0j,  # Bus 1 (slack) magnitude 1.03, angle 0
        1.00 + 0.0j,  # Bus 2
        1.00 + 0.0j,  # Bus 3
        1.00 + 0.0j   # Bus 4
    ], dtype=complex)

    # Build initial state vector x = [δ2, δ3, δ4, |V2|, |V3|, |V4|]
    ang_init = np.angle(v_init)          # radians
    mag_init = np.abs(v_init)

    x_np = np.array([
        ang_init[1],  # δ2
        ang_init[2],  # δ3
        ang_init[3],  # δ4
        mag_init[1],  # |V2|
        mag_init[2],  # |V3|
        mag_init[3]   # |V4|
    ], dtype=float)

    x = torch.tensor(x_np, dtype=torch.float64)

    for it in range(max_iter):
        # Enable gradients on x for this iteration
        x = x.detach().requires_grad_(True)

        # Compute calculated injections
        S_calc = power_injections(x)  # shape (6,)

        # Mismatch: spec - calc
        mismatch = S_spec - S_calc     # shape (6,)
        max_mis = mismatch.abs().max().item()

        print(f"Iteration {it+1}: max mismatch = {max_mis:.3e}")

        # Convergence check
        if max_mis < tol:
            print("Converged!")
            x = x.detach()
            break

        # Jacobian: dS_calc/dx
        J = jacobian(power_injections, x)  # shape (6,6)

        # Solve J * Δx = (S_spec - S_calc) = mismatch
        delta_x = torch.linalg.solve(J, mismatch)

        # Update state
        x = (x + delta_x).detach()

    else:
        print("WARNING: NR did not converge within max_iter")

    # Build final bus voltages from state vector x
    ang_final = np.zeros(4, dtype=float)
    mag_final = np.zeros(4, dtype=float)

    ang_final[0] = V1_ang
    mag_final[0] = V1_mag
    ang_final[1:4] = x[0:3].numpy()
    mag_final[1:4] = x[3:6].numpy()

    V_final = np.zeros(4, dtype=complex)
    for i in range(4):
        V_final[i] = cmath.rect(mag_final[i], ang_final[i])  # rect(r, phi) with phi in radians

    # Print results in polar form
    print("\nFinal bus voltages:")
    for i in range(4):
        mag = abs(V_final[i])
        ang_deg = math.degrees(cmath.phase(V_final[i]))
        print(f"  Bus {i+1}: |V| = {mag:.6f} pu, angle = {ang_deg:.6f} deg")

    # Also return raw data if you want to use it elsewhere
    return V_final, mag_final, ang_final, x


if __name__ == "__main__":
    V_final, mag_final, ang_final, x_state = newton_raphson_power_flow()

